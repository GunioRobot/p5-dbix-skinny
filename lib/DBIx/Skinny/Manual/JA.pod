=encoding utf8

=head1 NAME 

DBIx::Skinny::Manual::JA - DBIx::Skinnyの日本語ドキュメント

=head1 DESCRIPTION

Skinnyの総合的な使い方を網羅するマニュアルです。

Please translate and read the person in the sphere in English. 

=head1 注意

現在SkinnyはMySQLとSQLiteしかサポートしていません。
それはAuthorの私が現在そのRDBMSしか使っていないからです。

PostgreSQLやOracleなどが使いたい場合は、
DBIx::Skinny::DBD::*を作っていただく必要があります。

まだまだα版なので色々変わる事があるかもしれません。

=head2 Skinnyの基本クラスの定義

Skinnyを操作するClassを定義します。

例えばProjというプロジェクトでSkinnyを使う場合

    package Proj::Model;
    use DBIx::Skinny setup => +{
        dsn => 'dbi:SQLite:',
        username => '',
        password => '',
    };
    1;

このようなClassを用意します。
ちなみに、DBIx::Skinnyをuseすると

use strict;

use warnings

された事と同じ状態にします。

DBIx::Skinnyをuseする時の引数でdsnなどDBの接続に必要な情報を渡す事ができます。

.pmファイルに直接dsnなどを書きたくない場合は

    package Proj::Model;
    use DBIx::Skinny;
    1;

DBIx::Skinnyをuseする時の引数にdsnなどを書かずにClassを作成しておき、
DBにクエリを投げる前に

    Proj::Model->connect_info(....); # connect_infoを設定する

もしくは

    Proj::Model->connect(....): # connectメソッドをdsnなどの引数ともに呼び出す

としてやればよいです。

また元々dbのhandlerを別で持っている場合でそれを使い回したい場合は

    Proj::Model->set_dbh($dbh);

このようにset_dbhにhandlerを渡してやれば内部で持っているdatabase handlerを置き換える事ができます。

=head2 スキーマクラスの定義

Skinnyでは他のORマッパーと同じように各tableに対応するschemaの設定を書く必要があります。

例えばuserテーブルがある場合

    package Proj::Model::Schema;
    use DBIx::Skinny::Schema;
    
    install_table 'user' => schema {
        pk 'id';
        columns qw/
            id guid login_id login_pw name mail created_at updated_at
        /;
    };
    1;

DBIx::Skinny::SchemaをuseするとSchemaを構成するために必要なmethodがexportされます。

ちなみに、DBIx::Skinny::Schemaでもuseすると

use strict;

use warnings

された事と同じ状態にします。

この例ではuserテーブルの

プライマリキーはid
各カラムにはid/guid/login_id/login_pw/name/mail/created_at/updated_at

がある事を定義しています。

Skinnyでは他のORマッパーと異なり、テーブル毎にClassを作る必要はありません。

この例の場合Proj::Model::Schemaに全てのテーブル情報を記載します。

=head3 マルチバイトな値を扱うカラムについて

このuserテーブルの例でnameカラムがマルチバイトな文字列が入る場合でutf8flagの処理を自動で行いたい場合は

    package Proj::Model::Schema;
    use DBIx::Skinny::Schema;
    
    install_utf8_columns qw/name/;
    install_table 'user' => schema {
        pk 'id';
        columns qw/
            id guid login_id login_pw name mail created_at updated_at
        /;
    };
    1;

このようにinstall_utf8_columnsに対象となるカラム名を設定します。

ここで注意が必要なのですが、Skinnyは色々な割り切りを持って設計しています。

Skinnyの根本思想としてはモジュール利用者が好きに生のSQLを食わせて、
その結果をちょっといい感じのオブジェクトに纏めて
ちょっと楽をしようというものです。

この好きに生のSQLを食わせる為に色々な割り切りをしています。

思想については別の項目で書きます。

脱線しましたがinstall_utf8_columnsに対象となるカラム名を設定するのですが
この設定はSkinnyで取り扱う全テーブルに対しての設定となります。

ですのでuserテーブル以外のテーブルにnameカラムがあった場合、
install_utf8_columnsにnameを設定しているとuserテーブル以外のテーブルのnameカラムもutf8flag周りの処理が行われます。

=head3 inflate/deflateの処理について

Skinnyにもinflate/deflateの処理を書く事ができます

userテーブルの例の場合でcreated_at/updated_atなカラムをDateTimeでinflate/deflateしたい場合は

    package Proj::Model::Schema;
    use DBIx::Skinny::Schema;
    use DateTime;
    use DateTime::Format::Strptime;
    use DateTime::Format::MySQL;
    use DateTime::TimeZone;
    
    my $timezone = DateTime::TimeZone->new(name => 'Asia/Tokyo');
    install_inflate_rule '^.+_at$' => callback {
        inflate {
            my $value = shift;
            my $dt = DateTime::Format::Strptime->new(
                pattern   => '%Y-%m-%d %H:%M:%S',
                time_zone => $timezone,
            )->parse_datetime($value);
            return DateTime->from_object( object => $dt );
        };
        deflate {
            my $value = shift;
            return DateTime::Format::MySQL->format_datetime($value);
        };
    };
    
    install_table 'user' => schema {
        pk 'id';
        columns qw/
            id guid login_id login_pw name mail created_at updated_at
        /;
    };
    1;

例えばこのように書きます。

install_inflate_ruleに対象となるカラムのルールを書きます。
ここは正規表現で書く事ができます。

install_inflate_ruleもinstall_utf8_columnsと同様Skinnyで扱う全テーブルが対象となります。

=head3 triggerについて

Skinnyにもinsert/update/deleteなどを行った場合にtriggerによるHookをかける事ができます。

例えばinsert時にcreated_atを自動で設定するtriggerをかけたい場合は

    package Proj::Model::Schema;
    use DBIx::Skinny::Schema;
    use DateTime;
    
    install_table 'user' => schema {
        pk 'id';
        columns qw/
            id guid login_id login_pw name mail created_at updated_at
        /;
        trigger pre_insert => sub {
            my ( $class, $args ) = @_;
            $args->{created_at} ||= DateTime->now;
        };
    };
    1;

例えばこのように書きます

現在トリガーを設定できるポイントは

pre_insert / post_insert / pre_update / post_update / pre_delete / post_delete

があります

トリガーはテーブル単位で設定する事ができます

またトリガーは同じHookポイントに対して複数設定する事もできます。
同じHookポイントに複数設定した場合は設定した順番に実行されます。

=head2 connection_info / connect /reconnect / set_dbh

=head3 connection_info

connect_infoメソッドではDB接続情報を設定します

    Proj::Model->connection_info({
        dsn      => 'dbi:mysql:test',
        username => 'username',
        password => 'password'
        connect_options => +{
            RaiseError => 1,
            PrintError => 0,
            AutoCommit => 1,
        },
    });

connection_infoメソッドを呼び出した時点ではDBの接続は確立されません。

また引数で渡しているconnect_optionsは特に指定されなければ、
内部では

RaiseError: 1

PrintError: 0

AutoCommit: 1

でDBに接続されます。


=head3 connect

明示的にDB接続を行いたい場合はconnectメソッドを使用します。

    Proj::Model->connect({
        dsn      => 'dbi:mysql:test',
        username => 'username',
        password => 'password'
        connect_options => +{
            RaiseError => 1,
            PrintError => 0,
            AutoCommit => 1,
        },
    });


=head3 reconnect

一度DBに接続された状態で他のDBに接続しなおしたい場合は
reconnectメソッドを使用します。

    Proj::Model->reconnect({
        dsn      => 'dbi:mysql:test',
        username => 'username',
        password => 'password'
        connect_options => +{
            RaiseError => 1,
            PrintError => 0,
            AutoCommit => 1,
        },
    });

reconnectメソッドを呼び出すと呼び出す前まで保持していたdatabase handlerは破棄されます。

=head3 set_dbh

既にdatabase handlerを別で管理しており、Skinnyでそのhandlerを使いたい場合は
set_dbhメソッドを使用します。

    Proj::Model->set_dbh($dbh);

set_dbhメソッドを呼び出すと呼び出す前まで保持していたdatabase handlerは破棄されます。

=head2 dbh

dbhメソッドを呼び出すとその時点でのdatabase handlerが取得できます。

    my $dbh = Proj::Model->dbh;

=head2 do

doメソッドは$dbh->doのショートカットになっています。

    Proj::Model->do(q{
        CREATE TABLE foo (
            id   INT,
            name TEXT
        )
    });

=head2 insert / create

userテーブルにレコードをinsertするには以下のようにします。

    my $row = Proj::Model->insert('user',{
        name => 'nekokak',
        mail => 'nekokak _at_ gmail.com',
    });

insertメソッドの返り値はSkinnyのRowクラスになっていますので

    print $row->name; # nekokak
    print $row->mail; # nekokak _at_ gmail.com

このようにカラム名をメソッドとしてデータにアクセスできます

また、createメソッドはinsertメソッドのエイリアスになっているのでどちらでもOKです

    my $row = Proj::Model->create('user',{
        name => 'nekokak',
        mail => 'nekokak _at_ gmail.com',
    });

=head2 update

userテーブルのレコードをupdateするには以下のようにします。

    Proj::Model->update('user', {name => 'yappo'}, {id => 1})

一つ目のhashrefが更新する情報で
二つ目のhashrefが更新対象とするレコードの条件です。

また、Rowクラスから直接updateをかけることもできます。

    my $row = Proj::Model->insert('user',{
        name => 'nekokak',
        mail => 'nekokak _at_ gmail.com',
    });
    $row->update({name => 'yappo'});

=head2 delete

userテーブルのレコードをdeleteするには以下のようにします

    Proj::Model->delete('user', {id => 1});

hashrefでdelete対象とするレコードの条件を指定できます。

またdeleteメソッドもupdateメソッドと同じくRowクラスから直接deleteをかけることもできます。

    my $row = Proj::Model->insert('user',{
        name => 'nekokak',
        mail => 'nekokak _at_ gmail.com',
    });
    $row->delete;

=head2 bulk_insert

userテーブルに一気に複数行insertをかけたい場合は以下のようにします。

    Proj::Model->bulk_insert('user',
        [
            {
                name => 'nekokak',
                mail => 'nekokak _at_ gmail.com',
            },
            {
                name => 'yappo',
                mail => 'yappo _at_ example.com',
            },
        ]
    );

bulk_insertでは現状insertのトリガーは利用できませんのでご注意ください。

=head2 find_or_create / find_or_insert

userテーブルに指定した条件のレコードが存在すればその行をselectし
レコードが存在しなければinsertを行うことが出来ます。

    my $row = Proj::Model->find_or_create('user',{
        name => 'nekokak',
        mail => 'nekokak _at_ gmail.com',
    });

また、find_or_insertメソッドはfind_or_createメソッドのエイリアスになっているのでどちらでもOKです

    my $row = Proj::Model->find_or_insert('user',{
        name => 'nekokak',
        mail => 'nekokak _at_ gmail.com',
    });

=head2 single / search / search_named /search_by_sql / count

=head3 single

userテーブル１行だけ取得したい場合に使用します。

    my $row = Proj::Model->single('user',{name => 'nekokak'});

=head3 search

userテーブルに対してselectクエリを発行する場合にsearchメソッドを使用します。

    my $itr = Proj::Model->search('user',
        {
            name => 'nekokak',
        },
        { }
    );

二つ目のhashrefに検索条件
三つ目のhashrefにorderやlimitなどのオプションを渡せます。

searchメソッドはメソッドの返り値をスカラーコンテキストで受けるかリストコンテキストでうけるかで
返り値の情報が変わりま。
スカラーコンテキストで受けた場合はDBIx::Skinny::Iteratorが取得でき、
リストコンテキストで受けた場合は結果Rowの配列を取得することができます。

=head3 count

userテーブルのcountをとりたい場合はcountメソッドを使用します。

    my $count = Porj::Model->count('user' => 'id', {name => 'nekokak'});

二つ目の引数がcountを取る対象となるカラム情報で
三つ目の引数がcountを取る条件となります。

=cut

